#include "utlam.h"
#include <stdlib.h>
#include <string.h>

Env *env_push(char *name, Term *t, Env *env) {
    Env *new_head = malloc_or_die(sizeof(Env));
    new_head->name = name;
    new_head->t = t;
    new_head->next = env;
    return new_head;
}

Env *env_pop(Env *env) {
    Env *next = env->next;
    free(env);
    return next;
}

Term *env_get(char *name, Env *env) {
    while (env) {
        if (strcmp(name, env->name) == 0) {
            return env->t;
        }
        env = env->next;
    }
    return NULL;
}

Term *eval_app(Term *app, Env *env) {
    TermChoice tc = app->tc;
    Term *t1 = tc.app.t1;
    Term *t2 = tc.app.t2;
    Term *v2 = eval(t2, env);
    Term *v1 = eval(t1, env);
    if (v1->type != ABS) {
        tc.app.t1 = v1;
        tc.app.t2 = v2;
        tc.app.reducible = 0;
        return app;
        //error(EVAL_ERR, "Can only apply abstractions");
    }
    env = env_push(v1->tc.abs.arg, v2, env);
    Term *result = eval(v1->tc.abs.body, env);
    env = env_pop(env);
    return result;
}

Term *eval(Term *t, Env *env) {
    //printf("eval(%s)\n", t ? term_to_string(t) : "null");
    TermType type = t->type;
    TermChoice tc = t->tc;
    Term *result;
    if (type == APP) {
        
    } else {
    
    }
    switch (type) {
        case VAR:
            result = env_get(t->name, env);
            result = result ? result : t;
            break;
        case ABS:
            env = env_push(tc.abs.arg, NULL, env);
            t->tc.abs.body = eval(t->tc.abs.body, env);
            env = env_pop(env);
            result = t;
            break;
        case APP:
            result = tc.app.reducible ? eval_app(t, env) : t;
            break;
    }
    //printf("eval'd(%s)\n", t ? term_to_string(t) : "null");
    return result;
}

